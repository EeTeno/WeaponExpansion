INIT

EVENTS

EVENT LLWEAPONEX_FumbleRoll
VARS
	CHARACTER:_Attacker
	CHARACTER:_Source
	INT:_Ran
ON
	OnCharacterStartAttackObject(_, _, _, _Attacker)
ACTIONS
IF "c1&c2"
	CharacterHasStatus(_Attacker, LLWEAPONEX_CONCUSSION)
	CharacterGetStatusSourceCharacter(_Attacker, LLWEAPONEX_CONCUSSION, _Source)
THEN
	GetRandomBetween(_Ran, 0, 100)
	IF "c1"
		IsLessThen(_Ran, 10)
	THEN
		CharacterApplyStatus(_Attacker, LLWEAPONEX_FUMBLE, 0, 1, _Source)
	ENDIF
ENDIF

EVENT LLWEAPONEX_TrippingKnockdown
VARS
	CHARACTER:_Target
	CHARACTER:_Source
ON
	OnCharacterStatusAttempt(_Target, LLWEAPONEX_TRIPPING)
ACTIONS
IF "c1&c2"
	CharacterHasStatus(_Target, LLWEAPONEX_TRIPPING)
	CharacterGetStatusSourceCharacter(_Target, LLWEAPONEX_TRIPPING, _Source)
THEN
	CharacterApplyStatus(_Target, KNOCKED_DOWN, 1, 0, _Source)
ENDIF

EVENT LLWEAPONEX_DragonsBane_GuaranteedKnockdown
VARS
	CHARACTER:_Target
	CHARACTER:_Source
ON
	OnCharacterStatusApplied(_Target, LLWEAPONEX_DRAGONS_BANE)
ACTIONS
IF "!c1&c2"
	CharacterHasStatus(_Target, KNOCKED_DOWN)
	CharacterGetStatusSourceCharacter(_Target, LLWEAPONEX_DRAGONS_BANE, _Source)
THEN
	CharacterApplyStatus(_Target, KNOCKED_DOWN, 1, 1, _Source)
ENDIF

//If LLWEAPONEX_MAGIC_KNOCKDOWN_CHECK is applied, that means they have 0 magic armor and aren't immune to knockdown
EVENT LLWEAPONEX_MagicKnockdownCheck
VARS
	CHARACTER:_Target
	CHARACTER:_Source
	INT:_Turns
ON
	OnCharacterStatusApplied(_Target, LLWEAPONEX_MAGIC_KNOCKDOWN_CHECK)
ACTIONS
IF "!c1&c2&c3"
	CharacterHasStatus(_Target, KNOCKED_DOWN) // Don't force if they're already knocked down
	CharacterGetStatusSourceCharacter(_Target, LLWEAPONEX_MAGIC_KNOCKDOWN_CHECK, _Source)
	GetStatusTurns(_Target, LLWEAPONEX_MAGIC_KNOCKDOWN_CHECK, _Turns)
THEN
	Clamp(_Turns, 0, _Turns) // Permanent knockdown prevention
	CharacterApplyStatus(_Target, KNOCKED_DOWN, _Turns, 1, _Source)
ENDIF
	CharacterRemoveStatus(_Target, LLWEAPONEX_MAGIC_KNOCKDOWN_CHECK)
	
EVENT LLWEAPONEX_MagicBleedingCheck
VARS
	CHARACTER:_Target
	CHARACTER:_Source
	INT:_Turns
ON
	OnCharacterStatusApplied(_Target, LLWEAPONEX_MAGIC_BLEEDING_CHECK)
ACTIONS
IF "!c1&c2&c3"
	CharacterHasStatus(_Target, BLEEDING) // Don't force if they're already bleeding
	CharacterGetStatusSourceCharacter(_Target, LLWEAPONEX_MAGIC_BLEEDING_CHECK, _Source)
	GetStatusTurns(_Target, LLWEAPONEX_MAGIC_BLEEDING_CHECK, _Turns)
THEN
	Clamp(_Turns, 0, _Turns)
	CharacterApplyStatus(_Target, BLEEDING, _Turns, 1, _Source)
ENDIF
	CharacterRemoveStatus(_Target, LLWEAPONEX_MAGIC_BLEEDING_CHECK)
	
EVENT LLWEAPONEX_MagicCrippledCheck
VARS
	CHARACTER:_Target
	CHARACTER:_Source
	INT:_Turns
ON
	OnCharacterStatusApplied(_Target, LLWEAPONEX_MAGIC_CRIPPLED_CHECK)
ACTIONS
IF "!c1&c2&c3"
	CharacterHasStatus(_Target, CRIPPLED)
	CharacterGetStatusSourceCharacter(_Target, LLWEAPONEX_MAGIC_CRIPPLED_CHECK, _Source)
	GetStatusTurns(_Target, LLWEAPONEX_MAGIC_CRIPPLED_CHECK, _Turns)
THEN
	Clamp(_Turns, 0, _Turns)
	CharacterApplyStatus(_Target, CRIPPLED, _Turns, 1, _Source)
ENDIF
	CharacterRemoveStatus(_Target, LLWEAPONEX_MAGIC_CRIPPLED_CHECK)

/*
EVENT LLWEAPONEX_Tar_BurningBypass
VARS
	CHARACTER:_Character
	CHARACTER:_Source
	INT:_BurningTurns
ON
	OnCharacterCharacterEvent(_Character, "LLWEAPONEX_Burning_ArmorBypass")
ACTIONS
IF "c1&c2"
	GetStatusTurns(_Character, LLWEAPONEX_TARRED, _BurningTurns)
THEN
	IF "c1"
		CharacterGetStatusSourceCharacter(_Character, BURNING, _Source)
	THEN
	
	ENDIF
	IF "c1"
		IsLessThen(_BurningTurns, 1)
	THEN
		Set(_BurningTurns, 1)
	ENDIF
	CharacterApplyStatus(_Character, BURNING, _BurningTurns, 1, _Source)
ENDIF
*/

EVENT LLWEAPONEX_DeathSentence_Block
VARS
	CHARACTER:_Character
ON
	OnCharacterStatusRemoved(_Character, LLWEAPONEX_DEATH_SENTENCE)
ACTIONS
IF "!c1"
	CharacterIsDead(_Character, 1)
THEN
	CharacterApplyStatus(_Character, LLWEAPONEX_DEATH_SENTENCE_BLOCKED, 4, 0)
ENDIF

EVENT LLWEAPONEX_Shocked_Block
VARS
	CHARACTER:_Character
	CHARACTER:_Source
	INT:_Turns
ON
	OnCharacterStatusApplied(_Character, LLWEAPONEX_RUNEBLADE_SHOCKED)
ACTIONS
IF "!c1&c2&c3"
	CharacterHasStatus(_Character, LLWEAPONEX_SHOCKED_RESISTANCE_RUNEBLADE)
	GetStatusTurns(_Character, LLWEAPONEX_RUNEBLADE_SHOCKED, _Turns)
	CharacterGetStatusSourceCharacter(_Character, LLWEAPONEX_RUNEBLADE_SHOCKED, _Source)
THEN
	Clamp(_Turns, 0, _Turns)
	CharacterApplyStatus(_Character, SHOCKED, _Turns, 0, _Source)
ENDIF
	CharacterRemoveStatus(_Character, LLWEAPONEX_RUNEBLADE_SHOCKED, null, 0)
/*
EVENT LLWEAPONEX_Kevin_MiniExplosion
VARS
	CHARACTER:_Target
	CHARACTER:_Player
	FLOAT:_LevelF
	INT:_Level
ON
	OnCharacterStatusApplied(_Target, LLWEAPONEX_KEVIN_MINIEXPLOSION)
ACTIONS
IF "c1&c2"
	CharacterGetStatusSourceCharacter(_Target, LLWEAPONEX_KEVIN_MINIEXPLOSION, _Player)
	CharacterGetStat(_LevelF, _Player, Level)
THEN
	Cast(_Level, _LevelF)
	ExplodeAt(_Target, Projectile_LLWEAPONEX_Kevin_MiniExplosion, _Level, _Player)
ENDIF
*/

EVENT LLWEAPONEX_DeflectProjectiles_CountdownStart
VARS
	CHARACTER:_Character
ON
	OnEnteredCombat(_Character, _)
ACTIONS
IF "c1&!c2"
	CharacterHasStatus(_Character, LLWEAPONEX_DEFLECT_PROJECTILES_INNATE)
	CharacterHasStatus(_Character, LLWEAPONEX_DEFLECT_PROJECTILES_COUNTDOWN)
THEN
	CharacterApplyStatus(_Character, LLWEAPONEX_DEFLECT_PROJECTILES_COUNTDOWN, 4, 0, _Character)
ENDIF

EVENT LLWEAPONEX_DeflectProjectiles_CountdownCancel_LeftCombat
VARS
	CHARACTER:_Character
ON
	OnLeftCombat(_Character, _)
ACTIONS
IF "c1"
	CharacterHasStatus(_Character, LLWEAPONEX_DEFLECT_PROJECTILES_COUNTDOWN)
THEN
	CharacterRemoveStatus(_Character, LLWEAPONEX_DEFLECT_PROJECTILES_COUNTDOWN)
ENDIF

EVENT LLWEAPONEX_DeflectProjectiles_CountdownCancel_NotInCombat
VARS
	CHARACTER:_Character
	STATUS:_Result
	LIST<STATUS>:_RemoveList
ON
	FetchCharacterApplyStatusData(_Character, LLWEAPONEX_DEFLECT_PROJECTILES_COUNTDOWN)
ACTIONS
	Set(_Result, LLWEAPONEX_DEFLECT_PROJECTILES_COUNTDOWN)
IF "!c1|!c2"
	IsInCombat(_Character)
	CharacterHasStatus(_Character, LLWEAPONEX_DEFLECT_PROJECTILES_INNATE)
THEN
	Set(_Result, null)
	ListAdd(_RemoveList, LLWEAPONEX_DEFLECT_PROJECTILES)
	CombatLogText(_Character, "LLWEAPONEX_CombatLog_DeflectProjectilesCountdownFailed", 1, 1)
ENDIF
	RETURN(_RemoveList, _Result, null)